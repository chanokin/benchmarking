A different way of encoding spikes is using their \emph{Rank-order}; this means
keep just the order in which they were fired and disregard the exact timing. One
can see this as a compromise between the complexity of time-based encoding and 
the small capacity to store information of rate-based codes. Rank-ordered spike 
trains have been used in vision tasks under a biological plausibility 
constraint [\cite{van-rullen-rate-coding,basab-model}], making them a viable
way of image encoding for neural applications.

Rank-ordered encoding is done using an algorithm that models the foveal pit 
as reported by \cite{basab-model}. As a first step four 2D discrete 
\emph{convolutions} are performed. Each convolution simulates a ganglion cell 
type and all cells are modelled using Differences of Gaussians (DoG, 
Eq.~\ref{eq-dog}). \begin{equation}
\label{eq-dog}
DoG_w(x,y) = \pm\frac{1}{2\pi\sigma_{w,c}^2}e^{\frac{-(x^2 + y^2)}{2\sigma_{w,c}^2}}
\mp\frac{1}{2\pi\sigma_{w,s}^2}e^{\frac{-(x^2 + y^2)}{2\sigma_{w,s}^2}}
\end{equation}
where $\sigma_{w,c}$ and $\sigma_{w,s}$ are the standard deviation for the 
centre and surround components of the DoG at scale $w$ (cell type). The signs 
will be ($-$,$+$) if the ganglion cell has an \emph{off-centre} behaviour and 
($+$,$-$) if it has an \emph{on-centre} one. Table~\ref{tab-kernel-specs} 
describes the parameters used to compute the convolution \emph{kernels} at each 
scale $w$.

\begin{table}[htb]
  \caption{Simulation parameters for ganglion cells}
  \centering
  \begin{tabular}{l c c c c}
    \begin{minipage}{1.2cm}Cell type \end{minipage}& 
    \begin{minipage}{1cm} \centering Matrix width \end{minipage}&  
    \begin{minipage}{1.3cm}\centering Centre std. dev. ($\sigma_c$)\vspace*{0.1cm}\end{minipage} & 
    \begin{minipage}{1.3cm}\centering Surround std. dev. ($\sigma_s$)\vspace*{0.1cm}\end{minipage} & 
    \begin{minipage}{1.3cm}\centering Sampling resolution (cols,rows)\vspace*{0.1cm}\end{minipage} \\
    \hline
    \begin{minipage}{1.32cm}\vspace*{0.1cm} Midget Off-centre \vspace*{0.005cm} \end{minipage}& 
    \begin{minipage}{1cm}\centering$3$ \end{minipage}& 
    $0.8$ & $6.7 \times \sigma_c$ &  1, 1 \\
    \begin{minipage}{1.32cm} Midget On-centre \vspace*{0.005cm}\end{minipage} & 
    \begin{minipage}{1cm}\centering $11$ \end{minipage}& 
    $1.04$ & $6.7 \times \sigma_c$ & 1, 1 \\
    \begin{minipage}{1.32cm}Parasol Off-centre \vspace*{0.005cm}\end{minipage} & 
    \begin{minipage}{1cm}\centering $61$ \end{minipage}& 
    $8$ & $4.8 \times \sigma_c$ & 5, 3 \\
    \begin{minipage}{1.32cm} Parasol On-centre \vspace*{0.005cm}\end{minipage} & 
    \begin{minipage}{1cm}\centering $243$\end{minipage} &
    $10.4$ & $4.8 \times \sigma_c$ & 5, 3 
  \end{tabular}
  \label{tab-kernel-specs}
\end{table}

Every pixel in the convolved images (Fig. \ref{fig-convolution-results}) 
represent a spike emission time, the higher the pixel value, the sooner the 
spike will be sent out.

\begin{figure}[hbt]
  \centering
  \subfloat[Original image]{
    \label{sfig-rank-ordered-original}
    \includegraphics[width=0.15\textwidth]{original_5_1}
  }
  \subfloat[Midget OFF-centre]{
    \label{sfig-rank-ordered-midget-off}
    \includegraphics[width=0.15\textwidth]{filtered_focal_5_1_0}
  }
  \subfloat[Midget ON-centre]{
    \label{sfig-rank-ordered-midget-on}
    \includegraphics[width=0.15\textwidth]{filtered_focal_5_1_1}
  }\\
  \subfloat[Parasol OFF-centre]{
    \label{pic-lena-P-OFF}
    \includegraphics[width=0.15\textwidth]{filtered_focal_5_1_2}
  }
  \subfloat[Parasol ON-centre]{
    \label{pic-lena-P-ON}
    \includegraphics[width=0.15\textwidth]{filtered_focal_5_1_3}
  }
  \caption{Results of simulating ganglion cells (convolved images are enhanced for better contrast)}
  \label{fig-convolution-results}
\end{figure}

The algorithm also performs redundancy a correction step on adjusting the 
convolved image's weights according to the correlation between convolution 
kernels. At each iteration of the correction step, the maximum coefficient  
value (stored on each pixel location) of all images is picked, ``taken out'' 
and its surrounding pixels get adjusted according to the correlation between 
convolution kernels (Alg. \ref{code-focal}).

\begin{algorithm}
  \caption{~~Redundancy Correction}
  \label{code-focal}
  \begin{algorithmic}
    \Procedure{FoCal$_2$}{coefficients $C$, correlations $K$}
      \State $N \leftarrow \emptyset$ \Comment{Corrected coefficients}
      \Repeat
        \State $m \leftarrow max(C)$
        \State $M \leftarrow M \cup m$
        \State $C \leftarrow C \setminus m$
        \ForAll{$ c \in C$} \Comment{Adjust all remaining c}
          \If{$K(m, c) \neq 0$} \Comment{Adjust only near}
            \State $c \leftarrow c - m \times K(m, c)$
          \EndIf
        \EndFor
      \Until{$C = \emptyset$}
      \State \textbf{return} $M$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

